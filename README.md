## 7. Циклы

![img.svg](img%2Fimg.svg)

Концепция циклов является одной из фундаментальных и неотъемлемых частей программирования. Они позволяют нам повторять
определенные действия или операции в программе до тех пор, пока выполняются определенные условия. Циклы обеспечивают
эффективность и гибкость в обработке повторяющихся задач, а их понимание является важным шагом в освоении
программирования.

Добро пожаловать в увлекательную и важную тему программирования!

В этой теме рассмотрим два основных типа циклов - `while` и `for`, а также их возможности и применение. Также, изучим 
вложенные циклы, которые позволяют выполнять циклы внутри других циклов, что расширяет наши возможности в обработке 
сложных задач.

---

- [Цикл while](#цикл-while)
- [Цикл for](#цикл-for)
- [Встроенная функция range()](#встроенная-функция-range)
- [Вложенные циклы](#вложенные-циклы)
- [Примеры шаблонов с использованием вложенных циклов](#примеры-шаблонов-с-использованием-вложенных-циклов)
- [Задания по теме](#задания)

---

Представим, что вы студент и у вас есть список оценок по предметам за семестр, и ваша задача - просуммировать все эти
оценки.

Как это будет выглядеть без использования циклов:

Для начала, вы можете создать переменную `"общая_сумма"` и установить ее значение равным нулю. Затем вручную
просматриваете каждую оценку в списке и добавляете ее значение к `"общей_сумме"`.

Например, если у вас есть оценки `[85, 92, 77, 88]`, вы будете выполнять следующие действия:

1. Создать переменную `"общая_сумма"` и установить ее равной `нулю`;
2. Взять первую оценку `85` и добавить ее к `"общей_сумме"`. Теперь `"общая_сумма"` равна `85`;
3. Взять вторую оценку `92` и добавить ее к `"общей_сумме"`. Теперь `"общая_сумма"` равна `85 + 92 = 177`;
4. Взять третью оценку `77` и добавить ее к `"общей_сумме"`. Теперь `"общая_сумма"` равна `177 + 77 = 254`;
5. Взять четвертую оценку `88` и добавить ее к `"общей_сумме"`. Теперь `"общая_сумма"` равна `254 + 88 = 342`.

В результате, после вручного подсчета всех оценок, у вас будет значение переменной `"общая_сумма"`,
которое представляет собой сумму всех оценок за семестр.

Хотя такой подход возможен для небольшого количества оценок, использование циклов позволяет
автоматизировать этот процесс и справиться с большими списками данных более эффективно.

---

### Цикл `while`

Цикл `while` - это одна из основных конструкций циклов в языках программирования. Он позволяет выполнять повторяющийся
блок кода до тех пор, пока указанное условие остается истинным. Синтаксис цикла `while` выглядит следующим образом:

```
while условие:
    # выполняемые действия
```

Когда цикл `while` выполняется, сначала происходит проверка условия. Если условие истинно, то выполняется блок кода
внутри цикла. После этого снова происходит проверка условия и так далее, пока условие остается истинным.

```python
# Вывести числа от 1 до 5
num = 1
while num <= 5:
    print(num)
    num += 1
```

В данном примере цикл `while` используется для вывода чисел от `1` до `5`. Изначально переменная `num` инициализируется
значением `1`. Затем условие `num <= 5` проверяется: если оно истинно, то выводится значение `num`, а затем `num`
увеличивается на `1`. Процесс повторяется до тех пор, пока `num` меньше или равна `5`.

```python
# Вычислить сумму чисел от 1 до 10
total_sum = 0
num = 1
while num <= 10:
    total_sum += num
    num += 1
print("Сумма чисел от 1 до 10:", total_sum)  # 55
```

В данном примере цикл `while` используется для вычисления суммы чисел от `1` до `10`. Переменная `total_sum`
инициализируется значением `0`, а переменная `num` инициализируется значением `1`. При каждой итерации значение `num`
добавляется к сумме `total_sum`, а затем `num` увеличивается на `1`. Цикл продолжается до тех пор, пока `num` меньше 
или равна `10`. В конце программы выводится вычисленная сумма чисел.

Цикл `while` может быть полезен в различных ситуациях, где количество итераций неизвестно заранее и зависит от условия.
Однако необходимо быть внимательными, чтобы избежать бесконечного выполнения цикла, если условие всегда остается
истинным.

Пример использования цикла `while` для чтения пользовательского ввода:

```python
while (letter := input("Введите букву: ")) != "Выход":
    print(letter * 5)
```

В этом примере переменная `letter` присваивает введенное значение с помощью моржового оператора `:=`. Затем
условие `(letter := input("Введите букву: ")) != "Выход"` проверяется. Если введенная буква не равна `"Выход"`, то
выполняется блок кода, который выводит букву повторенную пять раз. После этого цикл снова проверяет условие и
продолжается до тех пор, пока пользователь не введет `"Выход"`.

---

### Цикл `for`

Цикл `for` - еще одна мощная конструкция цикла, которая используется для итерации по последовательности или коллекции
объектов. Он позволяет выполнять блок кода для каждого элемента в заданной последовательности без явного контроля
индекса.

Синтаксис цикла `for` выглядит следующим образом:

```
for элемент in последовательность:
    # выполняемые действия
```

Когда цикл `for` выполняется, он последовательно присваивает каждый элемент из заданной последовательности
переменной `"элемент"` и выполняет блок кода внутри цикла для каждого элемента.

```python
# Вывести все элементы списка
fruits = ["яблоко", "банан", "груша"]

for fruit in fruits:
    print(fruit)
```

В данном примере цикл `for` используется для вывода всех элементов списка `fruits`. Переменная `fruit` последовательно
принимает значение каждого элемента списка, и блок кода внутри цикла выводит текущий элемент. Цикл продолжается до тех
пор, пока не будут перебраны все элементы списка.

```python
# Вычислить сумму чисел от 1 до 5
summa = 0

for n in range(1, 6):
    summa += n
print("Сумма чисел от 1 до 5:", summa)  # 15
```

В этом примере цикл `for` используется для вычисления суммы чисел от `1` до `5`. Функция `range(1, 6)` создает
последовательность чисел от `1` до `5` (включительно). Переменная `n` последовательно принимает каждое значение из этой
последовательности, и блок кода внутри цикла добавляет текущее значение к переменной `summa`. В конце программы
выводится вычисленная сумма чисел.

```python
user_input = int(input("Введите целое число: "))

for _ in range(user_input):
    print("Действие выполняется")
```

В данном примере запрашиваем у пользователя целое число с помощью функции `input()` и преобразуем его в целочисленный
формат с помощью `int()`. Затем используем цикл `for` с помощью функции `range()` для выполнения действия указанное
количество раз. Здесь переменная `_` используется в качестве временной переменной, чтобы указать, что мы не используем
ее значение внутри цикла. Вместо этого просто выполняем требуемое действие, в данном случае, выводим
сообщение `"Действие выполняется"`.

---

### Встроенная функция `range()`

В Python 3.x есть встроенная функция `range()`, которая позволяет создавать последовательности чисел. Она имеет
несколько форматов использования, которые могут быть полезны при работе с циклами, особенно с циклом `for`.

Эта функция генерирует последовательность чисел, начиная с заданного начального
значения и заканчивая указанным конечным значением, с определенным шагом.

Синтаксис функции `range()`:

* `range(конечное_значение)`
* `range(начальное_значение, конечное_значение)`
* `range(начальное_значение, конечное_значение, шаг)`

Использование `range()` для создания последовательности чисел от 0 до 4:

```python
for num in range(5):
    print(num)
```

Вывод:

```
0
1
2
3
4
```

`range(5)` создает последовательность чисел от `0` до `4`. Цикл `for` используется для итерации
по этой последовательности, и каждое число выводится на экран. Обратите внимание, что конечное значение в
функции `range()` не включается.

Использование `range()` для создания последовательности чисел от 1 до 10 с шагом 2:

```python
for num in range(1, 11, 2):
    print(num)
```

Вывод:

```
1
3
5
7
9
```

Здесь функция `range(1, 11, 2)` создает последовательность чисел от `1` до `10` с шагом `2`. Цикл `for` используется для
итерации по этой последовательности, и каждое число выводится на экран. Здесь указано начальное значение `1`, конечное
значение `11` (не включая его) и шаг `2`, что означает, что числа будут увеличиваться на `2` на каждой итерации.

Использование `range()` для создания последовательности чисел в обратном порядке:

```python
for num in range(10, 0, -1):
    print(num)
```

Вывод:

```
10
9
8
7
6
5
4
3
2
1
```

В этом примере функция `range(10, 0, -1)` создает последовательность чисел в обратном порядке от `10` до `1`. Цикл `for`
используется для итерации по этой последовательности, и каждое число выводится на экран. Здесь указано начальное
значение `10`, конечное значение `0` (не включая его) и шаг `-1`, что означает, что числа будут уменьшаться на `1` на
каждой итерации.

`range()` предоставляет гибкую возможность создания последовательностей чисел для использования в циклах и других
сценариях, где требуется генерация чисел с определенными параметрами.

Генерация последовательности с шагом 3 и преобразование в список:

```python
numbers = list(range(0, 10, 3))
print(numbers)  # [0, 3, 6, 9]
```

Генерация последовательности с шагом -2 и преобразование в кортеж:

```python
numbers = tuple(range(10, 0, -2))
print(numbers)  # (10, 8, 6, 4, 2)
```

`range()` также позволяет генерировать последовательности чисел с отрицательными значениями начального и конечного
диапазона, а также отрицательным шагом.

Пример, когда начало, конец и шаг отрицательны:

```python
numbers = list(range(-10, -20, -2))
print(numbers)  # [-10, -12, -14, -16, -18]
```

Здесь `range(-10, -20, -2)` создает последовательность чисел в обратном порядке от `-10` до `-19` с шагом `-2`. Затем с
помощью функции `list()` преобразуем результат в список.

---

### Вложенные циклы

В программировании вложенные циклы используются для обработки структур данных, где одна структура содержит в себе другую
структуру, например, списки внутри списков или словари внутри словарей. Они позволяют перебирать элементы внутри
элементов и выполнять необходимые операции для каждой комбинации элементов.

Представьте, что вы пекарь и вам необходимо испечь печенье различных форм и размеров. У вас есть наборы различных форм,
и для каждой формы вы должны создать несколько экземпляров печенья разного размера. Вам нужно организовать процесс
выпечки, используя вложенные циклы.

Вы начинаете с первой формы и перебираете каждый размер печенья, который необходимо приготовить. Затем для каждого
размера печенья выпекаете необходимое количество экземпляров. Таким образом, проходите по каждому размеру печенья
для каждой формы и выпекаете нужное количество экземпляров.

В результате вложенных циклов вы обеспечиваете выпечку печенья всех размеров и форм, которые необходимы. Это пример, как
вложенные циклы позволяют эффективно обрабатывать множество элементов внутри другого множества.

Пример программного кода, который иллюстрирует эту задачу вложенных циклов с помощью вложенных `for`:

```python
cookie_shapes = ['круглая', 'квадратная', 'звездная']
cookie_sizes = ['маленькое', 'среднее', 'большое']

for shape in cookie_shapes:
    for size in cookie_sizes:
        print("Выпекаем", size, shape, "печенье.")
        # Здесь могут быть дополнительные действия, связанные с выпечкой печенья
```

В этом примере у нас есть список форм печенья `cookie_shapes` и список размеров печенья `cookie_sizes`. Вложенные
циклы `for` позволяют перебирать каждую форму и каждый размер, и для каждой комбинации формы и размера выполнять
определенные действия. В данном случае просто выводим сообщение о том, какое печенье мы выпекаем.

Результат выполнения кода будет следующим:

```
Выпекаем маленькое круглая печенье.
Выпекаем среднее круглая печенье.
Выпекаем большое круглая печенье.
Выпекаем маленькое квадратная печенье.
Выпекаем среднее квадратная печенье.
Выпекаем большое квадратная печенье.
Выпекаем маленькое звездная печенье.
Выпекаем среднее звездная печенье.
Выпекаем большое звездная печенье.
```

Этот же пример, с помощью вложенных циклов `while`:

```python
cookie_shapes = ['круглая', 'квадратная', 'звездная']
cookie_sizes = ['маленькое', 'среднее', 'большое']

shape_index = 0
while shape_index < len(cookie_shapes):
    size_index = 0
    while size_index < len(cookie_sizes):
        shape = cookie_shapes[shape_index]
        size = cookie_sizes[size_index]
        print("Выпекаем", size, shape, "печенье.")
        # Здесь могут быть дополнительные действия, связанные с выпечкой печенья
        size_index += 1
    shape_index += 1
```

Здесь внешний цикл выполняется, пока индекс формы печенья `shape_index` меньше длины списка `cookie_shapes`. Внутренний
цикл выполняется, пока индекс размера печенья `size_index` меньше длины списка `cookie_sizes`.

На каждой итерации внутреннего цикла получаем текущие значения формы и размера печенья, выводим сообщение о выпечке
печенья, а затем инкрементируем (увеличиваем) `size_index`. После завершения внутреннего цикла, инкрементируем 
(увеличиваем) `shape_index` и переходим к следующей форме печенья.

Результат выполнения кода будет таким же, как и в примере с использованием вложенных `for`.

В цикле `while` мы сами управляем индексами и условиями продолжения циклов. Как видите можем использовать `while` для
достижения того же результата, что и с использованием вложенных `for`.

Пример использования `while` и `for` в сочетании для реализации вложенных циклов:

```python
cookie_shapes = ['круглая', 'квадратная', 'звездная']
cookie_sizes = ['маленькое', 'среднее', 'большое']

shape_index = 0
while shape_index < len(cookie_shapes):
    shape = cookie_shapes[shape_index]
    for size in cookie_sizes:
        print("Выпекаем", size, shape, "печенье.")
        # Здесь могут быть дополнительные действия, связанные с выпечкой печенья
    shape_index += 1
```

В этом примере используем цикл `while` для перебора форм печенья из списка `cookie_shapes`. Внутри цикла `while`
используем цикл `for`, который перебирает все размеры печенья из списка `cookie_sizes` для каждой формы.

Результат выполнения кода будет таким же, как и в примерах с использованием только `while` или только `for`.

Выбор цикла в программе зависит от следующих факторов:

* Цикл `for` удобно использовать, когда известно явное условие или требуется выполнить итерации определенное количество
  раз, основываясь на длине списка или заданном диапазоне чисел.
* Цикл `while` предпочтительнее, когда условие выполнения цикла неизвестно заранее и требуется гибко изменять условие
  выполнения на основе произвольных условий или внешних факторов.
* Цикл `for` удобен для работы с итерируемыми объектами, такими как списки, кортежи, строки и др. Он автоматически
  обрабатывает итерацию без явного управления индексами или условиями продолжения.
* Вложенные циклы `while` предоставляют большую гибкость и контроль при сложных вложенных итерациях или требовании более
  тонкого управления ходом выполнения цикла.

При выборе между `while` и `for`, также полезно учитывать читаемость и понятность кода. Если ваша задача легко
выразиться с использованием `for` и это делает код более понятным, то стоит предпочесть `for`. Однако, если условия или
требования вашей задачи лучше выражаются с помощью `while`, то используйте `while`.
Нет жестких правил и в конечном счете вы должны выбрать тот цикл, который лучше соответствует вашим конкретным
потребностям и облегчает понимание и поддержку вашего кода.

---

### Примеры шаблонов с использованием вложенных циклов

Примеры шаблонов с использованием вложенных циклов позволяют демонстрировать, как можно эффективно использовать циклы
для решения различных задач. Рассмотрим несколько примеров.

**Шаблон 1: Прямоугольник из символов**

Этот шаблон позволяет создать прямоугольник заданного размера из определенного символа. Внутренний цикл отвечает за
повторение символа в одной строке, а внешний цикл управляет созданием строк и формирует прямоугольник.

```python
width = 5  # ширина
height = 3  # высота

for i in range(height):
    for j in range(width):
        print('*', end=' ')
    print()
```

```commandline
* * * * * 
* * * * * 
* * * * * 
```

**Шаблон 2: Треугольник из чисел**

Позволяет создать треугольник из чисел, где каждая строка содержит числа в возрастающем порядке. Внутренний цикл
управляет генерацией чисел, а внешний формированием строк треугольника.

```python
rows = 5

for i in range(rows):
    for j in range(i + 1):
        print(j + 1, end=' ')
    print()
```

Вывод:

```commandline
1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5 
```

**Шаблон 3: Шахматная доска**

Позволяет создать шахматную доску с помощью символов.

* &#9632; - Черный квадрат;
* &#9633; - Белый квадрат;

Внешний цикл управляет созданием строк, а вложенный формированием паттерна(шаблона) доски.

```python
size = 8

for i in range(size):
    for j in range(size):
        if (i + j) % 2 == 0:
            print('■', end=' ')
        else:
            print('□', end=' ')
    print()
```

Вывод:

```commandline
■ □ ■ □ ■ □ ■ □ 
□ ■ □ ■ □ ■ □ ■ 
■ □ ■ □ ■ □ ■ □ 
□ ■ □ ■ □ ■ □ ■ 
■ □ ■ □ ■ □ ■ □ 
□ ■ □ ■ □ ■ □ ■ 
■ □ ■ □ ■ □ ■ □ 
□ ■ □ ■ □ ■ □ ■ 
```

**Шаблон 4: Пирамида из символов**

Позволяет создать пирамиду заданной высоты из символов. Внутренний цикл отвечает за повторение символа в одной строке, а
внешний цикл управляет созданием строк и формированием пирамиды.

```python
height = 5
row = 1

# Пока номер текущей строки не превышает заданную высоту
while row <= height:
    space = height - row  # Вычисляем количество пробелов перед символами *

    count = 1
    # Пока номер текущего символа не превышает заданную высоту
    while count <= height:
        if count <= space:
            # Выводим пробел, если текущий символ находится перед символами *
            print(' ', end=' ')
        else:
            # Выводим символ *, если текущий символ находится в пирамиде
            print('*', end=' ')
        count += 1

    print()  # Переходим на новую строку после вывода строки пирамиды
    row += 1  # Переходим к следующей строке пирамиды
```

```commandline
        * 
      * * 
    * * * 
  * * * * 
* * * * * 
```

Для успешного использования и адаптации шаблонов с вложенными циклами рекомендуем учесть следующие советы:

* Изучите, как каждый цикл работает и взаимодействует друг с другом. Обратите внимание на последовательность итераций и
  изменение переменных;
* Перед написанием кода разбейте задачу на более мелкие шаги и определите, какие циклы понадобятся для каждого шага;
* Не бойтесь пробовать разные шаблоны и изменять условия циклов. Используйте отладку и вывод результатов для проверки и
  корректировки кода.

Помните, что развитие навыков программирования требует времени и практики. Чем больше вы пишете код и пробуете разные
шаблоны, тем более опытным и креативным программистом становитесь!

---

Поздравляем с освоением основ циклов! В следующей теме мы изучим операторы управления циклом, которые позволяют более
гибко контролировать выполнение циклов. Рассмотрим такие операторы, как `break`, `continue`, `else` и ключевое
слово `pass`. Они помогут вам изменять ход выполнения циклов в зависимости от определенных условий.

---

### [Задания](./tasks/TASKS.md)
